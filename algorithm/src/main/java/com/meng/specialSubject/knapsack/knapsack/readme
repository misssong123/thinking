1.Q001Knapsack01 01背包问题
2.Q002CanPartition  分割等和子集(01背包实际应用-间接求解和直接求解)
3.Q003KnapsackComplete   完全背包问题
4.Q004NumSquares 完全背包问题
5.Q005CoinChange 完全背包问题
6.Q006CoinChangeII 完成背包问题
7.Q007KnapsackMany 多重背包问题
8.Q008maxValueBinary 多重背包问题(二进制优化)
9.Q009maxValueQueue 多重背包问题(单调栈优化)
10.Q010maxValueFix 混合背包问题
01背包和完全背包问题的总结:
    01 背包问题的状态转移方程为：dp[i][j] = max(dp[i-1][j],dp[i-1][j-v[i]]+w[i])
由于计算dp[i][j]的时候，依赖于dp[i-1][j] 。因此我们在改为「一维空间优化」时，需要确保dp[j-v[i]]
存储的是上一行的值，即确保dp[j-v[i]]还没有被更新，所以遍历方向是从大到小。
    完全背包问题的状态转移方程是：dp[i][j] = max(dp[i-1][j],dp[i][j-v[i]]+w[i])
由于计算 dp[i][j] 的时候，依赖于dp[i][j-v[i]] 。因此我们在改为「一维空间优化」时，需要确保dp[i][j-v[i]]
 存储的是当前行的值，即确保 dp[i][j-v[i]] 已经被更新，所以遍历方向是从小到大。
两者本质的不同在于进行状态转移时依赖了不同的格子：
01 背包依赖的是「上一行正上方的格子」和「上一行左边的格子」。
完全背包依赖的是「上一行正上方的格子」和「本行左边的格子」。
01背包和完全背包问题和多重背包问题的总结:
我们发现，只有「完全背包」的「一维空间优化」是存在数学意义上的优化（能够有效降低算法时间复杂度）。
「01 背包」和「多重背包」的「一维空间优化」其实只是基于「朴素二维」解法做单纯的「滚动」操作而已
（利用状态之间的依赖关系，配合遍历顺序，使得不再需要参与转移的空间能够被重新利用）。
因此，一定程度上，可以将「多重背包」看做是一种特殊的「01 背包」。
对「01 背包」中具有相同的价值 & 成本的物品进行计数，就成了对应物品的「限制件数」，
「01 背包」也就转换成了「多重背包」。
同理，将「多重背包」的多件物品进行「扁平化展开」，就转换成了「01 背包」。
在传统的三种背包问题的「一维空间优化」里，只有「完全背包」的「容量维度」是「从小到大」的，
其他两种背包的「容量维度」都是「从大到小」的。

